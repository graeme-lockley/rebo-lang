let FS = import("fs")
let Path = import("path")
let Str = import("str")

# The directory where the rebo binary is located.  This function is used particularly to locate the rebo
# utilities that form part of the rebo distribution.
let binHome() {    
   let exe = rebo.exe

   if exe |> Str.endsWith?("/zig-out/bin/rebo") -> Str.dropEnd(exe, 17) + "/bin"
    | Path.dir(exe)
}

let compile = rebo.os["bc.compile"]

let eval(bc, s) = rebo.os["bc.eval"](bc, s ? scope())

let dis(bc) {
   let ip = 0

   while ip < len(bc) -> {
      print(ip, ": ")

      let op = int(bc[ip])

      if op > len(ops()) -> { println("unknown opcode: ", op) ; ip := ip + 1 }
       | {
         print(ops()[op][0])

         ip := ip + 1

         each(ops()[op][1], fn(i) {
            match i
            | 'I' -> { print(" ", _readInt(bc, ip)) ; ip := ip + 8 }
            | 'C' -> { print(" ", bc[ip]) ; ip := ip + 1 }
            | 'F' -> { print(" ", _readFloat(bc, ip)) ; ip := ip + 8 }
            | 'P' -> { print(" ", _position(bc, ip)) ; ip := ip + 16 }
            | 'S' -> {
               let len = _readInt(bc, ip)
               let str = bc[ip + 8:ip + 8 + len]
               print(" ", str)
               ip := ip + 8 + len
            }
         })

         println()
      }
   }
}

let _readInt = rebo.os["bc.readInt"]

let _readFloat = rebo.os["bc.readFloat"]

let _position(bc, ip) {
   let start = _readInt(bc, ip)
   let end = _readInt(bc, ip + 8)

   if start == end -> str(start) 
    | (str(start) + "-" + str(end))
}

let findFile(name, path = ["."]) =
   if len(path) == 0 -> ()
    | _fexists(binHome() + "/" + path[0] + "/" + name) -> binHome() + "/" + path[0] + "/" + name
    | findFile(name, path[1:])

let _fexists(path) {
   println("fexists: ", path)

   fexists(path)
}

let _ops = ()

let ops() {
   if _ops == () -> _ops := _loadOpsFile(binHome() + "/../src/bc-interpreter/ops.zig")

   _ops
}

let _loadOpsFile(path) =
   FS.lines(path)
      |> map(fn(l) Str.trim(l)) 
      |> filter(fn(line) len(line) > 0 && !Str.startsWith?(line, "pub const") && !Str.startsWith?(line, "}")) 
      |> map(fn(l) split(l, "//")) 
      |> map(fn(l) [Str.dropEnd(Str.trim(l[0]), 1), Str.trim(l[1] ? "")])
